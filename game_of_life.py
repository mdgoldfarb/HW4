# -*- coding: utf-8 -*-
"""Game_of_life

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J_PxCT2jxCNPX2fj777soTwkl5PHFQjG
"""

# Matt Goldfarb 113346370

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import sys

def eh(k):  # Error handling
    try:
        k = int(k)  # Convert input to an integer
        if k <= 0:
            raise ValueError("Cannot have a negative or zero k value")
        return k
    except ValueError as e:
        print("Error: " + str(e))
        sys.exit(1)

if len(sys.argv) > 1:
    k = eh(sys.argv[1])
else:
    k = 100

grid = np.zeros((20, 20))  # Initialize the grid
glider = [[False, False, True], [True, False, True], [False, True, True]]  # Make the true/false values
grid[8:11, 8:11] = np.array(glider)  # Position the glider near the center

def evolve(grid):  # The function for evolve
    new_grid = np.zeros((20, 20))  # Make a new grid the same size as the original
    for i in range(20):
        for j in range(20):  # Nested loops for the rows/columns
            if grid[i % 20, j % 20] == False:  # Conditions for the dead cells
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) == 3:
                    new_grid[i % 20, j % 20] = True
            if grid[i % 20, j % 20] == True:  # Conditions for the live cells
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) > 3:
                    new_grid[i % 20, j % 20] = False
                if 2 <= (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) <= 3:
                    new_grid[i % 20, j % 20] = True
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) < 2:
                    new_grid[i % 20, j % 20] = False
    return new_grid

def visualize(grid):  # The function to visualize the grid
    plt.imshow(grid, cmap='binary')

try:
    for i in range(k):
        if i % 10 == 0:  # Use it in this loop with the modular function helping the image print out after every tenth step
            visualize(grid)
        grid = evolve(grid
        )
    fig, ax = plt.subplots()
    def animate(frame):
        ax.clear()
        ax.imshow(grid, cmap='binary')
        grid[:] = evolve(grid)
    video = animation.FuncAnimation(fig, animate, frames=k, interval=100)  # Make the video with the animation.FuncAnimation function
    plt.imsave('game_of_life.png', grid, cmap='binary')  # Save the final image
    video.save('game_of_life.gif', writer='pillow', fps=10)  # Save the video
    plt.imshow(grid, cmap='binary')
    plt.colorbar()
    plt.show()
except Exception as e:
    print("An error occurred: " + str(e))