# -*- coding: utf-8 -*-
"""Game_of_life

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J_PxCT2jxCNPX2fj777soTwkl5PHFQjG
"""

# Matt Goldfarb 113346370

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import sys

def eh(k):#Error handling
     """
    Error handling function for ensuring k is a positive integer.

    Parameters:
        k (int): The value of k to be validated.

    Returns:
        int: If k is a positive integer.

    Raises:
        ValueError: If k is not a positive integer.

    """
    try:
        k=int(k)#Convert input to an integer
        if k<=0:
            raise ValueError("Cannot have a negative or zero k value")
        return k
    except ValueError as e:
        print("Error: "+str(e))#Catches the error and throws in the statement
        sys.exit(1)

if len(sys.argv)>1: #implement the sys.argv to make it so we can type A value in the terminal
    k=eh(sys.argv[1])
else:
    k=100 #Default value

grid=np.zeros((20,20)) #Initialize the grid
glider=[[False, False, True], [True, False, True], [False, True, True]] #Make the true/false values
grid[8:11, 8:11]=np.array(glider)  # Position the glider near the center

def evolve(grid):  # The function for evolve
     """
    Function to evolve the grid according to the rules of Conway's Game of Life.

    Parameters:
        grid (numpy.ndarray): The current state of the grid.

    Returns:
        numpy.ndarray: The updated grid after one iteration.

    """
    new_grid=np.zeros((20, 20)) #Make a new grid the same size as the original
    for i in range(20):
        for j in range(20): #Nested loops for the rows/columns
            if grid[i % 20, j % 20] == False: #Conditions for the dead cells
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) == 3:#Sum of all the neighboring values (TRUE=1, FALSE=0)
                    new_grid[i % 20, j % 20] = True
            if grid[i % 20, j % 20] == True: #Conditions for the live cells
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) > 3:
                    new_grid[i % 20, j % 20] = False
                if 2 <= (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) <= 3:
                    new_grid[i % 20, j % 20] = True
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) < 2:
                    new_grid[i % 20, j % 20] = False
    return new_grid

def visualize(grid):  #The function to visualize the grid
    """
    Function to visualize the grid using Matplotlib.

    Parameters:
        grid (numpy.ndarray): The grid to be visualized.

    """
    plt.imshow(grid, cmap='binary')

try:
    for i in range(k):
        if i%10==0:  # Use it in this loop with the modular function helping the image print out after every tenth step
            visualize(grid)
        grid=evolve(grid)
    fig, ax=plt.subplots() #Make subplots for the video
    def animate(frame): #Defining a function that will make the animation
        """
    Function to animate the evolution of the grid and update the display.

    Parameters:
        frame (int): The current frame number in the animation.

    """
        ax.clear()
        ax.imshow(grid, cmap='binary')
        grid[:]=evolve(grid) #So that the evolve function can work
    video = animation.FuncAnimation(fig, animate, frames=k, interval=100)  # Make the video with the animation.FuncAnimation function
    plt.imsave('game_of_life.png', grid, cmap='binary') #Save the final image
    video.save('game_of_life.gif', writer='pillow', fps=10)  #Save the video, pillow method makes it into a gif
    plt.imshow(grid, cmap='binary')
    plt.colorbar()
    plt.show()
except Exception as e: #Exception in case something goes wrong during the video making
    print("An error occurred: "+str(e))
