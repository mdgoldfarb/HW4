# -*- coding: utf-8 -*-
"""Game_of_life

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J_PxCT2jxCNPX2fj777soTwkl5PHFQjG
"""

# Matt Goldfarb 113346370

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import sys

def eh(k):#Error handling
     """
    The Error Handling functions helps make it so k is a positive integer through a try except block
    Parameters:
        k (int): The value of k to be validated.
    Output(s):
        If k is a positive integer, the code will continue.
        If k is not a positive integer, it raises the error message
    """
    try:
        k=int(k)#Convert input to an integer
        if k<=0:
            raise ValueError("Cannot have a negative or zero k value")
        return k
    except ValueError as e:
        print("Error: "+str(e))#Catches the error and throws in the statement
        sys.exit(1)

if len(sys.argv)>1: #implement the sys.argv to make it so we can type A value in the terminal
    k=eh(sys.argv[1])
else:
    k=100 #Default value

grid=np.zeros((20,20)) #Initialize the grid
glider=[[False, False, True], [True, False, True], [False, True, True]] #Make the true/false values
grid[8:11, 8:11]=np.array(glider)  # Position the glider near the center

def evolve(grid):  # The function for evolve
     """
    The evolve function updates the grid according to the rules of Conway's Game of Life for one iteration using nested loops and conditional statements based off the sum of the neighbors of the current block. A new grid is made of the same size and its squares will be updated based on the original grid
    Parameters:
        A grid which is a grid using numpy, usually.
    Output:
        The updated grid using the original grid.
    """
    new_grid=np.zeros((20, 20)) #Make a new grid the same size as the original
    for i in range(20):
        for j in range(20): #Nested loops for the rows/columns
            if grid[i % 20, j % 20] == False: #Conditions for the dead cells
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) == 3:#Sum of all the neighboring values (TRUE=1, FALSE=0)
                    new_grid[i % 20, j % 20] = True
            if grid[i % 20, j % 20] == True: #Conditions for the live cells
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) > 3:
                    new_grid[i % 20, j % 20] = False
                if 2 <= (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) <= 3:
                    new_grid[i % 20, j % 20] = True
                if (grid[(i + 1) % 20, j % 20] + grid[(i - 1) % 20, j % 20] + grid[(i + 1) % 20, (j + 1) % 20] + grid[(i + 1) % 20, (j - 1) % 20] + grid[(i - 1) % 20, (j + 1) % 20] + grid[(i - 1) % 20, (j - 1) % 20] + grid[i % 20, (j + 1) % 20] + grid[i % 20, (j - 1) % 20]) < 2:
                    new_grid[i % 20, j % 20] = False
    return new_grid

def visualize(grid):  #The function to visualize the grid
    """
    The visualize function is to visualize the grid using Matplotlib. This is used for showing the updates to the original grid after using the evolve function.
    Parameters:
        The grid to be visualized.
    Output: 
        The visualized grid which is on a plane with a black/white scale.
    """
    plt.imshow(grid, cmap='binary')

try:
    for i in range(k):
        if i%10==0:  # Use it in this loop with the modular function helping the image print out after every tenth step
            visualize(grid)
        grid=evolve(grid)
    fig, ax=plt.subplots() #Make subplots for the video
    def animate(frame): #Defining a function that will make the animation
        """
    The animate function is to show the evolution of the grid and update the display. It has ax and fig to make subplots of the grid and use the evolve function recursively.

    Parameters:
        The current frame number in the animation which is an integer and it goes through a loop.
    Output:
        It goes through the video (FuncAnimation) function which makes it a gif with k frames of the grid and the rotating glider or other shape in the Game of Life.
    """
        ax.clear()
        ax.imshow(grid, cmap='binary')
        grid[:]=evolve(grid) #So that the evolve function can work
    video = animation.FuncAnimation(fig, animate, frames=k, interval=100)  # Make the video with the animation.FuncAnimation function
    plt.imsave('game_of_life.png', grid, cmap='binary') #Save the final image
    video.save('game_of_life.gif', writer='pillow', fps=10)  #Save the video, pillow method makes it into a gif
    plt.imshow(grid, cmap='binary')
    plt.colorbar()
    plt.show()
except Exception as e: #Exception in case something goes wrong during the video making
    print("An error occurred: "+str(e))
